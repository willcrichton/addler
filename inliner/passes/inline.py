import libcst as cst
import libcst.matchers as m
import inspect

from .base_pass import BasePass
from ..common import a2s, EvalException, get_function_locals, parse_statement
from .. import transforms


class InlinePass(BasePass):
    def __init__(self, add_comments=True):
        super().__init__()
        self.add_comments = add_comments

    def _inline(self, ret_var, call, func_obj):
        if inspect.isgeneratorfunction(func_obj):
            new_stmts = transforms.inline_generator(
                func_obj, call, ret_var, add_comments=self.add_comments)
        elif inspect.isfunction(func_obj):
            new_stmts = transforms.inline_function(
                func_obj, call, ret_var, add_comments=self.add_comments)
        elif inspect.isclass(func_obj):
            new_stmts = transforms.inline_constructor(
                func_obj, call, ret_var, add_comments=self.add_comments)
        elif inspect.ismethod(func_obj):
            new_stmts = transforms.inline_method(func_obj,
                                                 call,
                                                 ret_var,
                                                 add_comments=self.add_comments)
        else:
            raise NotImplemented

        self.insert_statements_before_current(new_stmts)

    def _func_name(self, func):
        if m.matches(func, m.Name()):
            return func.value
        elif m.matches(func, m.Attribute()):
            return func.attr.value
        else:
            return 'func'

    def _should_inline(self, func, func_obj):
        # If a function was generated by a higher-order function, we can't
        # directly inline it, must be inlined through the generator. This
        # is detected by checking if the function object has a closure.
        if not self.inliner.is_source_obj(func_obj):
            closure = get_function_locals(func_obj)
            if len(closure) > 0 and \
               not (len(closure) == 1
                    and next(iter(closure.keys())) == '__class__'):
                fdef = parse_statement(inspect.getsource(func_obj))

                if len(fdef.decorators) == 0:
                    return False

        # Can't inline the output of a higher order function directly
        not_higher_order = not m.matches(func, m.Call())

        return not_higher_order and self.inliner.should_inline(func)

    def leave_Call(self, _, call):
        func = call.func

        try:
            func_obj = self.inliner._eval(func)
        except EvalException as e:
            return call

        if self._should_inline(func, func_obj):
            func_name = self._func_name(func)
            ret_var = self.fresh_var(f'{func_name}_ret')

            self._inline(ret_var, call, func_obj)

            return cst.Name(ret_var)

        return call

    def leave_Assign(self, _, assgn):
        if m.matches(assgn, m.Assign(targets=[m.AssignTarget(m.Attribute())])):
            target = m.targets[0].target

        return assgn
